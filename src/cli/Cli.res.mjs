// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Ink from "ink";
import * as Utils from "./Utils.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as AuthCommand from "./AuthCommand.res.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as SubmitCommand from "./SubmitCommand.res.mjs";
import * as AnalyzeCommand from "./AnalyzeCommand.res.mjs";
import * as JjUtilsJs from "../lib/jjUtils.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as RemoteSelectionComponent from "./RemoteSelectionComponent.res.mjs";

function createJjFunctions(prim) {
  return JjUtilsJs.createJjFunctions(prim);
}

function isGitHubRemote(prim) {
  return JjUtilsJs.isGitHubRemote(prim);
}

var help = "🔧 jj-stack - Jujutsu Git workflow automation\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nUSAGE:\n  jj-stack [COMMAND] [OPTIONS]\n\nCOMMANDS:\n  submit <bookmark>     Submit a bookmark and all downstack bookmarks as PRs\n    --dry-run           Show what would be done without making changes\n    --remote <name>     Use the specified Git remote (must be a GitHub remote)\n\n  auth test             Test GitHub authentication\n  auth help             Show authentication help\n\n  help, --help, -h      Show this help message\n\nDEFAULT BEHAVIOR:\n  Running jj-stack without arguments analyzes and displays the current\n  graph of stacked bookmarks.\n\nEXAMPLES:\n  jj-stack                        # Show change graph\n  jj-stack submit feature-branch  # Submit feature-branch and downstack as PRs\n  jj-stack submit feature-branch --dry-run  # Preview what would be done\n  jj-stack submit feature-branch --remote upstream  # Use a specific remote\n  jj-stack auth test              # Test GitHub authentication\n\nFor more information, visit: https://github.com/keanemind/jj-stack\n";

async function resolveRemoteName(remotes, userSpecified) {
  if (userSpecified !== undefined) {
    var foundRemote = remotes.find(function (r) {
          return r.name === userSpecified;
        });
    if (foundRemote !== undefined) {
      if (!JjUtilsJs.isGitHubRemote(foundRemote.url)) {
        console.error("❌ Remote '" + userSpecified + "' is not a GitHub remote. Only GitHub remotes are supported.");
        process.exit(1);
        Js_exn.raiseError("");
      }
      return userSpecified;
    } else {
      console.error("❌ Remote '" + userSpecified + "' does not exist.");
      process.exit(1);
      return Js_exn.raiseError("");
    }
  }
  var githubRemotes = remotes.filter(function (r) {
        return JjUtilsJs.isGitHubRemote(r.url);
      });
  var match = githubRemotes.length;
  if (match !== 0) {
    if (match !== 1) {
      console.log("🔀 Multiple GitHub remotes found, opening interactive selector...");
      console.log();
      return await new Promise((function (resolve, _reject) {
                    var inkInstanceRef = {
                      contents: undefined
                    };
                    var component = JsxRuntime.jsx(RemoteSelectionComponent.make, {
                          remotes: githubRemotes,
                          onComplete: (function (selectedRemoteName) {
                              var instance = inkInstanceRef.contents;
                              if (instance !== undefined) {
                                instance.unmount();
                              }
                              resolve(selectedRemoteName);
                            })
                        });
                    var inkInstance = $$Ink.render(component);
                    inkInstanceRef.contents = inkInstance;
                  }));
    } else {
      return Belt_Array.getExn(githubRemotes, 0).name;
    }
  } else {
    console.error("❌ No GitHub remotes found. At least one GitHub remote is required.");
    process.exit(1);
    return Js_exn.raiseError("");
  }
}

function extractGlobalFlags(args) {
  var idx = args.findIndex(function (arg) {
        return arg === "--remote";
      });
  if (!(idx >= 0 && (idx + 1 | 0) < args.length)) {
    return [
            args,
            "origin"
          ];
  }
  var remoteName = Belt_Option.getWithDefault(args[idx + 1 | 0], "origin");
  var filteredArgs = args.slice(0, idx).concat(args.slice(idx + 2 | 0, args.length));
  return [
          filteredArgs,
          remoteName
        ];
}

async function main() {
  try {
    var jjPathResult = await Utils.getJJPath();
    var jjConfig = {
      binaryPath: jjPathResult.filepath
    };
    var jjFunctions = JjUtilsJs.createJjFunctions(jjConfig);
    var args = process.argv.slice(2, process.argv.length);
    var match = extractGlobalFlags(args);
    var remoteStr = match[1];
    var filteredArgs = match[0];
    var userSpecifiedRemoteOpt = remoteStr === "origin" ? undefined : remoteStr;
    var knownCommands = [
      "submit",
      "auth",
      "help",
      "--help",
      "-h"
    ];
    var command = Belt_Array.get(filteredArgs, 0);
    var isKnownCommand = Belt_Option.getWithDefault(Belt_Option.map(command, (function (cmd) {
                return knownCommands.includes(cmd);
              })), false);
    var remotes = await jjFunctions.getGitRemoteList();
    var remoteName = await resolveRemoteName(remotes, userSpecifiedRemoteOpt);
    if (command === undefined) {
      return await AnalyzeCommand.analyzeCommand(jjFunctions, remoteName);
    }
    if (!isKnownCommand) {
      return await AnalyzeCommand.analyzeCommand(jjFunctions, remoteName);
    }
    switch (command) {
      case "auth" :
          var match$1 = filteredArgs[1];
          if (match$1 === "test") {
            return await AuthCommand.authTestCommand();
          } else {
            return AuthCommand.authHelpCommand();
          }
      case "--help" :
      case "-h" :
      case "help" :
          console.log(help);
          return ;
      case "submit" :
          var bookmarkName = filteredArgs[1];
          if (bookmarkName !== undefined) {
            var isDryRun = filteredArgs.includes("--dry-run");
            return await SubmitCommand.submitCommand(jjFunctions, bookmarkName, {
                        dryRun: isDryRun,
                        remote: remoteName
                      });
          }
          console.error("Usage: jj-stack submit <bookmark-name> [--dry-run] [--remote <name>]");
          process.exit(1);
          return ;
      default:
        return ;
    }
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      var message = error._1.message;
      if (message !== undefined) {
        console.error("An error occurred: " + message);
        process.exit(1);
      } else {
        console.error("An unknown error occurred.");
        process.exit(1);
      }
      return ;
    }
    console.error("An unknown error occurred.");
    process.exit(1);
    return ;
  }
}

export {
  createJjFunctions ,
  isGitHubRemote ,
  help ,
  resolveRemoteName ,
  extractGlobalFlags ,
  main ,
}
/* ink Not a pure module */
