// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Process from "process";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as SubmitJs from "../lib/submit.js";

function analyzeSubmissionPlan(prim0, prim1) {
  return SubmitJs.analyzeSubmissionPlan(prim0, prim1);
}

function executeSubmissionPlan(prim0, prim1, prim2) {
  return SubmitJs.executeSubmissionPlan(prim0, prim1, prim2);
}

function getGitHubConfig(prim) {
  return SubmitJs.getGitHubConfig();
}

function formatBookmarkStatus(bookmark, existingPRs) {
  var hasExistingPR = existingPRs.get(bookmark.name);
  return "üìã " + bookmark.name + ": " + (
          bookmark.hasRemote ? "has remote" : "needs push"
        ) + ", " + (
          Core__Option.isSome(hasExistingPR) ? "has PR" : "needs PR"
        );
}

function createSubmissionCallbacks(dryRun) {
  return {
          onBookmarkValidated: (function (bookmark) {
              console.log("‚úÖ Found local bookmark: " + bookmark);
            }),
          onAnalyzingStack: (function (targetBookmark) {
              console.log("üîç Finding all bookmarks in stack for " + targetBookmark + "...");
            }),
          onStackFound: (function (bookmarks) {
              console.log("üìö Found stack bookmarks to submit: " + bookmarks.map(function (b) {
                          return b.name;
                        }).join(" -> "));
            }),
          onCheckingPRs: (function (_bookmarks) {
              
            }),
          onPlanReady: (function (plan) {
              console.log("üìç GitHub repository: " + plan.repoInfo.owner + "/" + plan.repoInfo.repo);
              plan.bookmarksToSubmit.forEach(function (bookmark) {
                    console.log(formatBookmarkStatus(bookmark, plan.existingPRs));
                  });
              if (dryRun) {
                console.log("\nüß™ DRY RUN - Simulating all operations:");
                console.log("=".repeat(50));
                if (plan.bookmarksNeedingPush.length > 0) {
                  console.log("\nüõú Would push " + plan.bookmarksNeedingPush.length.toString() + " bookmarks to remote:");
                  plan.bookmarksNeedingPush.forEach(function (bookmark) {
                        console.log("   ‚Ä¢ " + bookmark.name);
                      });
                }
                if (plan.bookmarksNeedingPR.length > 0) {
                  console.log("\nüìù Would create " + plan.bookmarksNeedingPR.length.toString() + " PRs:");
                  plan.bookmarksNeedingPR.forEach(function (create) {
                        console.log("   ‚Ä¢ " + create.bookmark.name + ": \"" + create.prContent.title + "\" (base: " + create.baseBranch + ")");
                      });
                }
                if (plan.bookmarksNeedingPRBaseUpdate.length > 0) {
                  console.log("\nüîÑ Would update " + plan.bookmarksNeedingPRBaseUpdate.length.toString() + " PR bases:");
                  plan.bookmarksNeedingPRBaseUpdate.forEach(function (update) {
                        console.log("   ‚Ä¢ " + update.bookmark.name + ": from " + update.currentBaseBranch + " to " + update.expectedBaseBranch);
                      });
                  return ;
                } else {
                  return ;
                }
              } else {
                if (plan.bookmarksNeedingPush.length > 0) {
                  console.log("\nüì§ Pushing " + plan.bookmarksNeedingPush.length.toString() + " bookmarks to remote...");
                }
                if (plan.bookmarksNeedingPR.length > 0) {
                  console.log("\nüìù Creating " + plan.bookmarksNeedingPR.length.toString() + " PRs...");
                  return ;
                } else {
                  return ;
                }
              }
            }),
          onPushStarted: (function (bookmark, remote) {
              console.log("Pushing " + bookmark.name + " to " + remote + "...");
            }),
          onPushCompleted: (function (bookmark, remote) {
              console.log("‚úÖ Successfully pushed " + bookmark.name + " to " + remote);
            }),
          onPRStarted: (function (bookmark, title, base) {
              console.log("Creating PR: " + bookmark.name + " -> " + base);
              console.log("   Title: \"" + title + "\"");
            }),
          onPRCompleted: (function (bookmark, pr) {
              console.log("‚úÖ Created PR for " + bookmark.name + ": " + pr.html_url);
              console.log("   Title: " + pr.title);
              console.log("   Base: " + pr.base.ref + " <- Head: " + pr.head.ref);
            }),
          onPRBaseUpdateStarted: (function (bookmark, currentBase, expectedBase) {
              console.log("Updating PR base for " + bookmark.name + " from " + currentBase + " to " + expectedBase + "...");
            }),
          onPRBaseUpdateCompleted: (function (bookmark, pr) {
              console.log("‚úÖ Updated PR base for " + bookmark.name + ": " + pr.html_url);
              console.log("   New Base: " + pr.base.ref + " <- Head: " + pr.head.ref);
            }),
          onError: (function (error, context) {
              var errorMessage = Core__Option.getOr(error.message, "Unknown error");
              console.error("‚ùå Error " + context + ": " + errorMessage);
            })
        };
}

async function submitCommand(bookmarkName, options) {
  var dryRun = options !== undefined ? Core__Option.getOr(options.dryRun, false) : false;
  if (dryRun) {
    console.log("üß™ DRY RUN: Simulating submission of bookmark: " + bookmarkName);
  } else {
    console.log("üöÄ Submitting bookmark: " + bookmarkName);
  }
  var callbacks = createSubmissionCallbacks(dryRun);
  var plan = await SubmitJs.analyzeSubmissionPlan(bookmarkName, callbacks);
  if (dryRun) {
    console.log("=".repeat(50));
    console.log("‚úÖ Dry run completed successfully!");
    return ;
  }
  var githubConfig = await SubmitJs.getGitHubConfig();
  console.log("üîë Using GitHub authentication from: configured");
  var result = await SubmitJs.executeSubmissionPlan(plan, githubConfig, callbacks);
  if (result.success) {
    console.log("\nüéâ Successfully submitted stack up to " + bookmarkName + "!");
    if (result.pushedBookmarks.length > 0) {
      console.log("   üì§ Pushed: " + result.pushedBookmarks.map(function (b) {
                  return b.name;
                }).join(", "));
    }
    if (result.createdPRs.length > 0) {
      var createdPrBookmarks = result.createdPRs.map(function (pr) {
            return pr.bookmark.name;
          });
      console.log("   üìù Created PRs: " + createdPrBookmarks.join(", "));
    }
    if (result.updatedPRs.length <= 0) {
      return ;
    }
    var updatedPrBookmarks = result.updatedPRs.map(function (pr) {
          return pr.bookmark.name;
        });
    console.log("   üîÑ Updated PRs: " + updatedPrBookmarks.join(", "));
    return ;
  }
  console.error("\n‚ùå Submission completed with errors:");
  result.errors.forEach(function (param) {
        var errorMessage = Core__Option.getOr(param.error.message, "Unknown error");
        console.error("   ‚Ä¢ " + param.context + ": " + errorMessage);
      });
  Process.exit(1);
}

export {
  analyzeSubmissionPlan ,
  executeSubmissionPlan ,
  getGitHubConfig ,
  formatBookmarkStatus ,
  createSubmissionCallbacks ,
  submitCommand ,
}
/* process Not a pure module */
