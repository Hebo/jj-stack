// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.res.mjs";
import * as Process from "process";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as SubmitJs from "../lib/submit.js";

function analyzeSubmissionGraph(prim) {
  return SubmitJs.analyzeSubmissionGraph(prim);
}

function createSubmissionPlan(prim0, prim1) {
  return SubmitJs.createSubmissionPlan(prim0, prim1);
}

function createNarrowedSegments(prim0, prim1) {
  return SubmitJs.createNarrowedSegments(prim0, prim1);
}

function executeSubmissionPlan(prim0, prim1, prim2) {
  return SubmitJs.executeSubmissionPlan(prim0, prim1, prim2);
}

function getGitHubConfig(prim) {
  return SubmitJs.getGitHubConfig();
}

function formatBookmarkStatus(bookmark, existingPRs) {
  var hasExistingPR = existingPRs.get(bookmark.name);
  return "üìã " + bookmark.name + ": " + (
          bookmark.hasRemote ? "has remote" : "needs push"
        ) + ", " + (
          Core__Option.isSome(hasExistingPR) ? "has PR" : "needs PR"
        );
}

function createExecutionCallbacks() {
  return {
          onPushStarted: (function (bookmark, remote) {
              console.log("Pushing " + bookmark.name + " to " + remote + "...");
            }),
          onPushCompleted: (function (bookmark, remote) {
              console.log("‚úÖ Successfully pushed " + bookmark.name + " to " + remote);
            }),
          onPRStarted: (function (bookmark, title, base) {
              console.log("Creating PR: " + bookmark.name + " -> " + base);
              console.log("   Title: \"" + title + "\"");
            }),
          onPRCompleted: (function (bookmark, pr) {
              console.log("‚úÖ Created PR for " + bookmark.name + ": " + pr.html_url);
              console.log("   Title: " + pr.title);
              console.log("   Base: " + pr.base.ref + " <- Head: " + pr.head.ref);
            }),
          onPRBaseUpdateStarted: (function (bookmark, currentBase, expectedBase) {
              console.log("Updating PR base for " + bookmark.name + " from " + currentBase + " to " + expectedBase + "...");
            }),
          onPRBaseUpdateCompleted: (function (bookmark, pr) {
              console.log("‚úÖ Updated PR base for " + bookmark.name + ": " + pr.html_url);
              console.log("   New Base: " + pr.base.ref + " <- Head: " + pr.head.ref);
            }),
          onError: (function (error, context) {
              var errorMessage = Core__Option.getOr(error.message, "Unknown error");
              console.error("‚ùå Error " + context + ": " + errorMessage);
            })
        };
}

async function submitCommand(bookmarkName, options) {
  var dryRun = options !== undefined ? Core__Option.getOr(options.dryRun, false) : false;
  if (dryRun) {
    console.log("üß™ DRY RUN: Simulating submission of bookmark: " + bookmarkName);
  } else {
    console.log("üöÄ Submitting bookmark: " + bookmarkName);
  }
  console.log("üîç Analyzing submission requirements for: " + bookmarkName);
  var analysis = await SubmitJs.analyzeSubmissionGraph(bookmarkName);
  console.log("‚úÖ Found stack with " + analysis.relevantSegments.length.toString() + " segment(s)");
  var resolvedBookmarks = await Utils.resolveBookmarkSelections(analysis);
  console.log("üìã Creating submission plan...");
  var narrowedSegments = SubmitJs.createNarrowedSegments(resolvedBookmarks, analysis);
  var plan = await SubmitJs.createSubmissionPlan(narrowedSegments, undefined);
  console.log("üìç GitHub repository: " + plan.repoInfo.owner + "/" + plan.repoInfo.repo);
  resolvedBookmarks.forEach(function (bookmark) {
        console.log(formatBookmarkStatus(bookmark, plan.existingPRs));
      });
  if (dryRun) {
    console.log("\nüß™ DRY RUN - Simulating all operations:");
    console.log("=".repeat(50));
    if (plan.bookmarksNeedingPush.length > 0) {
      console.log("üì§ Would push: " + plan.bookmarksNeedingPush.length.toString() + " bookmark(s)");
      plan.bookmarksNeedingPush.forEach(function (bookmark) {
            console.log("   ‚Ä¢ " + bookmark.name);
          });
    }
    if (plan.bookmarksNeedingPR.length > 0) {
      console.log("üìù Would create: " + plan.bookmarksNeedingPR.length.toString() + " PR(s)");
      plan.bookmarksNeedingPR.forEach(function (item) {
            console.log("   ‚Ä¢ " + item.bookmark.name + " (base: " + item.baseBranchOptions.join(" or ") + ")");
          });
    }
    if (plan.bookmarksNeedingPRBaseUpdate.length > 0) {
      console.log("üîÑ Would update: " + plan.bookmarksNeedingPRBaseUpdate.length.toString() + " PR base(s)");
      plan.bookmarksNeedingPRBaseUpdate.forEach(function (item) {
            console.log("   ‚Ä¢ " + item.bookmark.name + ": " + item.currentBaseBranch + " ‚Üí " + item.expectedBaseBranchOptions.join(" or "));
          });
    }
    console.log("=".repeat(50));
    console.log("‚úÖ Dry run completed successfully!");
    return ;
  }
  console.log("üîë Getting GitHub authentication...");
  var githubConfig = await SubmitJs.getGitHubConfig();
  var executionCallbacks = createExecutionCallbacks();
  var result = await SubmitJs.executeSubmissionPlan(plan, githubConfig, Caml_option.some(executionCallbacks));
  if (result.success) {
    console.log("\nüéâ Successfully submitted stack up to " + bookmarkName + "!");
    if (result.pushedBookmarks.length > 0) {
      console.log("   üì§ Pushed: " + result.pushedBookmarks.map(function (b) {
                  return b.name;
                }).join(", "));
    }
    if (result.createdPRs.length > 0) {
      var createdPrBookmarks = result.createdPRs.map(function (pr) {
            return pr.bookmark.name;
          });
      console.log("   üìù Created PRs: " + createdPrBookmarks.join(", "));
    }
    if (result.updatedPRs.length <= 0) {
      return ;
    }
    var updatedPrBookmarks = result.updatedPRs.map(function (pr) {
          return pr.bookmark.name;
        });
    console.log("   üîÑ Updated PRs: " + updatedPrBookmarks.join(", "));
    return ;
  }
  console.error("\n‚ùå Submission completed with errors:");
  result.errors.forEach(function (param) {
        var errorMessage = Core__Option.getOr(param.error.message, "Unknown error");
        console.error("   ‚Ä¢ " + param.context + ": " + errorMessage);
      });
  Process.exit(1);
}

export {
  analyzeSubmissionGraph ,
  createSubmissionPlan ,
  createNarrowedSegments ,
  executeSubmissionPlan ,
  getGitHubConfig ,
  formatBookmarkStatus ,
  createExecutionCallbacks ,
  submitCommand ,
}
/* Utils Not a pure module */
