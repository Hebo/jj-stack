// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Ink from "ink";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as BookmarkSelectionComponent from "./BookmarkSelectionComponent.res.mjs";

function sleep(ms) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve();
                      }), ms);
              }));
}

function changeIdToLogEntry(changeGraph, changeId) {
  var segment = Core__Option.getExn(changeGraph.bookmarkedChangeIdToSegment.get(changeId), undefined);
  return Core__Option.getExn(segment[0], undefined);
}

function isInteractiveUINeeded(segments) {
  return segments.some(function (segment) {
              return segment.bookmarks.length > 1;
            });
}

function getDirectBookmarkSelections(segments) {
  return segments.map(function (segment) {
              if (segment.bookmarks.length !== 1) {
                console.error("‚ùå Internal error: Expected single bookmark but found " + segment.bookmarks.length.toString());
                Js_exn.raiseError("Invalid state: getDirectBookmarkSelections called with multi-bookmark segment");
              }
              return Core__Option.getExn(segment.bookmarks[0], undefined);
            });
}

async function resolveBookmarkSelectionsWithUI(analysis) {
  var segments = analysis.relevantSegments;
  if (segments.length === 0) {
    console.error("‚ùå No segments provided for bookmark selection");
    return Js_exn.raiseError("No segments to process");
  } else if (isInteractiveUINeeded(segments)) {
    console.log("üîÄ Found changes with multiple bookmarks, opening interactive selector...");
    return await new Promise((function (resolve, reject) {
                  var inkInstanceRef = {
                    contents: undefined
                  };
                  var component = JsxRuntime.jsx(BookmarkSelectionComponent.make, {
                        segments: segments.slice().reverse(),
                        onComplete: (function (bookmarks) {
                            var instance = inkInstanceRef.contents;
                            if (instance !== undefined) {
                              instance.unmount();
                            }
                            if (bookmarks.length !== segments.length) {
                              console.error("‚ùå Selection mismatch: expected " + segments.length.toString() + " bookmarks, got " + bookmarks.length.toString());
                              return reject({
                                          RE_EXN_ID: "Failure",
                                          _1: "Selection count mismatch"
                                        });
                            } else {
                              return resolve(bookmarks.slice().reverse());
                            }
                          })
                      });
                  var inkInstance = $$Ink.render(component);
                  inkInstanceRef.contents = inkInstance;
                }));
  } else {
    console.log("üìã All changes have single bookmarks, proceeding automatically...");
    return getDirectBookmarkSelections(segments);
  }
}

async function resolveBookmarkSelections(analysis) {
  return await resolveBookmarkSelectionsWithUI(analysis);
}

export {
  sleep ,
  changeIdToLogEntry ,
  isInteractiveUINeeded ,
  getDirectBookmarkSelections ,
  resolveBookmarkSelectionsWithUI ,
  resolveBookmarkSelections ,
}
/* ink Not a pure module */
