// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Ink from "ink";
import * as Utils from "./Utils.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as SubmitJs from "../lib/submit.js";
import * as JjUtilsJs from "../lib/jjUtils.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as AnalyzeCommandComponent from "./AnalyzeCommandComponent.res.mjs";

function buildChangeGraph(prim) {
  return JjUtilsJs.buildChangeGraph();
}

function gitFetch(prim) {
  return JjUtilsJs.gitFetch();
}

function getExistingPRs(prim0, prim1, prim2, prim3) {
  return SubmitJs.getExistingPRs(prim0, prim1, prim2, prim3);
}

function getGitHubConfig(prim) {
  return SubmitJs.getGitHubConfig();
}

async function analyzeCommand() {
  console.log("Fetching from remote...");
  try {
    await JjUtilsJs.gitFetch();
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      console.error("Error fetching from remote: " + Core__Option.getOr(error._1.message, "Unknown error"));
    } else {
      throw error;
    }
  }
  console.log("Building change graph from user bookmarks...");
  var changeGraph = await JjUtilsJs.buildChangeGraph();
  var prStatusMap = new Map();
  var inDegrees = new Map();
  changeGraph.bookmarkedChangeAdjacencyList.forEach(function (parentChangeId) {
        inDegrees.set(parentChangeId, Core__Option.getOr(inDegrees.get(parentChangeId), 0) + 1 | 0);
      });
  var queue = Array.from(changeGraph.stackLeafs).toSorted(function (a, b) {
        var logEntryA = Utils.changeIdToLogEntry(changeGraph, a);
        var logEntryB = Utils.changeIdToLogEntry(changeGraph, b);
        return logEntryB.committedAt.getTime() - logEntryA.committedAt.getTime();
      });
  var topSort = [];
  while(queue.length > 0) {
    var changeId = Core__Option.getExn(queue.shift(), undefined);
    topSort.push(changeId);
    var parent = changeGraph.bookmarkedChangeAdjacencyList.get(changeId);
    if (parent !== undefined) {
      var newParentInDegrees = Core__Option.getExn(inDegrees.get(parent), undefined) - 1 | 0;
      if (newParentInDegrees > 0) {
        inDegrees.set(parent, newParentInDegrees);
      } else {
        queue.unshift(parent);
      }
    }
    
  };
  console.log(topSort);
  var output = [];
  var columns = [];
  topSort.forEach(function (changeId) {
        var prefColumnIdx = columns.findIndex(function (v) {
              return v === changeId;
            });
        if (prefColumnIdx === -1) {
          columns.push(changeId);
        }
        var changeColumnIdx = prefColumnIdx === -1 ? columns.length - 1 | 0 : prefColumnIdx;
        var nextRow = [];
        for(var _for = 0; _for < changeColumnIdx; ++_for){
          nextRow.push(" â”‚");
        }
        nextRow.push(" â—‹");
        for(var _for$1 = changeColumnIdx + 1 | 0 ,_for_finish = columns.length; _for$1 < _for_finish; ++_for$1){
          nextRow.push(" â”‚");
        }
        output.push({
              chars: nextRow,
              changeId: changeId
            });
        var parent = changeGraph.bookmarkedChangeAdjacencyList.get(changeId);
        if (parent !== undefined) {
          var parentColumnIdx = columns.findIndex(function (id) {
                return id === parent;
              });
          if (parentColumnIdx !== -1 && parentColumnIdx < changeColumnIdx) {
            columns.splice(changeColumnIdx, 1);
            var nextRow$1 = [];
            for(var _for$2 = 0; _for$2 < parentColumnIdx; ++_for$2){
              nextRow$1.push(" â”‚");
            }
            nextRow$1.push(" â”œ");
            for(var _for$3 = parentColumnIdx + 1 | 0; _for$3 < changeColumnIdx; ++_for$3){
              nextRow$1.push("â”€â”‚");
            }
            nextRow$1.push("â”€â•¯");
            for(var _for$4 = changeColumnIdx + 1 | 0 ,_for_finish$1 = columns.length; _for$4 < _for_finish$1; ++_for$4){
              nextRow$1.push(" â”‚");
            }
            output.push({
                  chars: nextRow$1,
                  changeId: ""
                });
            return ;
          }
          columns[changeColumnIdx] = parent;
          output.push({
                chars: " â”‚".repeat(columns.length).split(""),
                changeId: ""
              });
          return ;
        }
        if (changeColumnIdx > 0) {
          var nextRow$2 = [];
          nextRow$2.push(" â”œ");
          for(var _for$5 = 1; _for$5 < changeColumnIdx; ++_for$5){
            nextRow$2.push("â”€â”‚");
          }
          for(var _for$6 = changeColumnIdx ,_for_finish$2 = columns.length; _for$6 < _for_finish$2; ++_for$6){
            nextRow$2.push("â”€â•¯");
          }
          columns.splice(changeColumnIdx, 1);
          output.push({
                chars: nextRow$2,
                changeId: ""
              });
          return ;
        }
        output.push({
              chars: " â”‚".repeat(columns.length).split(""),
              changeId: ""
            });
      });
  output.push({
        chars: [" â—‹"],
        changeId: "trunk()"
      });
  output.forEach(function (line) {
        var bookmarksStr = line.changeId !== "" && line.changeId !== "trunk()" ? " (" + Utils.changeIdToLogEntry(changeGraph, line.changeId).localBookmarks.join(", ") + ")" : "";
        console.log(line.chars.join("") + " " + line.changeId + bookmarksStr);
      });
  $$Ink.render(JsxRuntime.jsx(AnalyzeCommandComponent.make, {
            changeGraph: changeGraph,
            prStatusMap: prStatusMap
          }));
  console.log("\n=== CHANGE GRAPH RESULTS ===");
  console.log("Total bookmarks: " + String(changeGraph.bookmarks.size));
  console.log("Total stacks: " + String(changeGraph.stacks.length));
  if (changeGraph.stacks.length > 0) {
    console.log("\n=== BOOKMARK STACKS ===");
    changeGraph.stacks.forEach(function (stack, i) {
          console.log("\nStack " + String(i + 1 | 0) + ":");
          console.log("  Bookmarks: " + stack.segments.flatMap(function (s) {
                      return s.bookmarks.map(function (b) {
                                  return b.name;
                                });
                    }).join(", "));
          var totalChanges = Core__Array.reduce(stack.segments, 0, (function (sum, segment) {
                  return sum + segment.changes.length | 0;
                }));
          console.log("  Total changes: " + String(totalChanges));
          if (stack.segments.length > 1) {
            console.log("  ðŸ“š This is a stacked set of bookmarks!");
            return ;
          }
          
        });
  }
  console.log("\n=== SEGMENT DETAILS ===");
  changeGraph.bookmarkedChangeIdToSegment.forEach(function (segmentChanges, changeId) {
        var logEntry = Core__Option.getExn(segmentChanges[0], undefined);
        console.log("\n" + changeId + " (" + logEntry.localBookmarks.join(", ") + "):");
        console.log("  Segment changes: " + String(segmentChanges.length));
        var match = segmentChanges.at(0);
        var match$1 = Core__Array.last(segmentChanges);
        if (match !== undefined && match$1 !== undefined) {
          console.log("  Latest: " + match.descriptionFirstLine);
          console.log("  Oldest: " + match$1.descriptionFirstLine);
          return ;
        }
        
      });
}

export {
  buildChangeGraph ,
  gitFetch ,
  getExistingPRs ,
  getGitHubConfig ,
  analyzeCommand ,
}
/* ink Not a pure module */
